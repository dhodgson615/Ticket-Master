===================================================================================================== test session starts ======================================================================================================
platform darwin -- Python 3.12.11, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/dhodgson/Desktop/Ticket-Master
configfile: pyproject.toml
plugins: anyio-4.11.0, cov-7.0.0
collected 436 items

tests/test_app.py .........FFFFFFFFF........                                                                                                                                                                             [  5%]
tests/test_auth.py ......................                                                                                                                                                                                [ 11%]
tests/test_branch.py ........                                                                                                                                                                                            [ 12%]
tests/test_colors.py ............FF.....................................F                                                                                                                                                [ 24%]
tests/test_commit.py ........                                                                                                                                                                                            [ 26%]
tests/test_data_scraper.py ..FF.                                                                                                                                                                                         [ 27%]
tests/test_database.py .......                                                                                                                                                                                           [ 29%]
tests/test_edge_cases.py ..................                                                                                                                                                                              [ 33%]
tests/test_examples.py ............                                                                                                                                                                                      [ 36%]
tests/test_git_objects.py ............................                                                                                                                                                                   [ 42%]
tests/test_github_utils.py ............F..F..........F...                                                                                                                                                                [ 49%]
tests/test_integration.py .FFF                                                                                                                                                                                           [ 50%]
tests/test_issue.py ........FF.FFF..FF.                                                                                                                                                                                  [ 54%]
tests/test_llm.py ...........................................                                                                                                                                                            [ 64%]
tests/test_main.py ......F........FFFF.FFFFF                                                                                                                                                                             [ 70%]
tests/test_new_classes.py ......................................FF.                                                                                                                                                      [ 79%]
tests/test_ollama_tools.py FFFFFFFFFFF........FFFFFFFFFFFFFFF                                                                                                                                                            [ 87%]
tests/test_performance.py FFF..F.......                                                                                                                                                                                  [ 90%]
tests/test_pipe.py .....                                                                                                                                                                                                 [ 91%]
tests/test_prompt.py ............                                                                                                                                                                                        [ 94%]
tests/test_pull_request.py .........                                                                                                                                                                                     [ 96%]
tests/test_repository.py ............F.F                                                                                                                                                                                 [100%]

=========================================================================================================== FAILURES ===========================================================================================================
______________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_private_repo_no_token ______________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce584d0>, mock_repository = <MagicMock name='Repository' id='4514718848'>, mock_load_config = <MagicMock name='load_config' id='4514690592'>
mock_github_utils = <MagicMock name='GitHubUtils' id='4516128592'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    @patch("app.Repository")
    def test_generate_issues_private_repo_no_token(
        self, mock_repository, mock_load_config, mock_github_utils
    ):
        """Test generate_issues with private repository but no token."""
        mock_load_config.return_value = {
            "github": {"token": None},
            "issue_generation": {"max_issues": 5},
        }

        # Mock GitHubUtils
        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:181: AttributeError
_____________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_nonexistent_local_path ______________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce585f0>, mock_repository = <MagicMock name='Repository' id='4516134640'>, mock_load_config = <MagicMock name='load_config' id='4514220656'>
mock_github_utils = <MagicMock name='GitHubUtils' id='4514224736'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    @patch("app.Repository")
    def test_generate_issues_nonexistent_local_path(
        self, mock_repository, mock_load_config, mock_github_utils
    ):
        """Test generate_issues with nonexistent local path."""
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
        }

        # Mock GitHubUtils
        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:208: AttributeError
_________________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_with_local_path _________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce58710>, mock_exists = <MagicMock name='exists' id='4514231072'>, mock_generate = <MagicMock name='generate_sample_issues' id='4513481456'>
mock_repository = <MagicMock name='Repository' id='4513485392'>, mock_load_config = <MagicMock name='load_config' id='4513489232'>, mock_github_utils = <MagicMock name='GitHubUtils' id='4513493072'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    @patch("app.Repository")
    @patch("app.generate_sample_issues")
    @patch("os.path.exists")
    def test_generate_issues_with_local_path(
        self,
        mock_exists,
        mock_generate,
        mock_repository,
        mock_load_config,
        mock_github_utils,
    ):
        """Test generate_issues with valid local path."""
        # Setup mocks
        mock_exists.return_value = True
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
            "repository": {},
            "llm": {"provider": "mock"},
        }

        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:246: AttributeError
__________________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_clone_failure __________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce587d0>, mock_load_config = <MagicMock name='load_config' id='4512349024'>, mock_github_utils = <MagicMock name='GitHubUtils' id='4512338800'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    def test_generate_issues_clone_failure(
        self, mock_load_config, mock_github_utils
    ):
        """Test generate_issues when repository cloning fails."""
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
        }

        # Mock GitHubUtils to fail on clone
        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:288: AttributeError
________________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_repository_error _________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce58920>, mock_repository = <MagicMock name='Repository' id='4512345040'>, mock_load_config = <MagicMock name='load_config' id='4512349264'>
mock_github_utils = <MagicMock name='GitHubUtils' id='4513760080'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    @patch("app.Repository")
    def test_generate_issues_repository_error(
        self, mock_repository, mock_load_config, mock_github_utils
    ):
        """Test generate_issues when repository analysis fails."""
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
        }

        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:315: AttributeError
_______________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_success_public_repo _______________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce58aa0>, mock_generate = <MagicMock name='generate_sample_issues' id='4513766704'>, mock_repository = <MagicMock name='Repository' id='4513770976'>
mock_load_config = <MagicMock name='load_config' id='4513775888'>, mock_github_utils = <MagicMock name='GitHubUtils' id='4513779728'>

    @patch("app.GitHubUtils")
    @patch("app.load_config")
    @patch("app.Repository")
    @patch("app.generate_sample_issues")
    def test_generate_issues_success_public_repo(
        self,
        mock_generate,
        mock_repository,
        mock_load_config,
        mock_github_utils,
    ):
        """Test successful issue generation for public repository."""
        # Setup mocks
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
            "repository": {},
            "llm": {"provider": "mock"},
        }

        mock_utils_instance = Mock()
>       mock_utils_instance.parse_github_url.return_value = self.test_repo
                                                            ^^^^^^^^^^^^^^
E       AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:351: AttributeError
__________________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_dry_run_flag ___________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce4bf20>

    def test_generate_issues_dry_run_flag(self):
        """Test that dry_run flag is properly processed."""
        with app.app.test_client() as client:
            with patch("app.GitHubUtils") as mock_github_utils:
                with patch("app.load_config") as mock_load_config:
                    mock_load_config.return_value = {
                        "github": {"token": "test_token"}
                    }

                    # Test with dry_run checkbox checked
>                   form_data = self.form_data.copy()
                                ^^^^^^^^^^^^^^
E                   AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'form_data'

tests/test_app.py:393: AttributeError
_______________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_max_issues_default ________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce58980>

    def test_generate_issues_max_issues_default(self):
        """Test that max_issues defaults to 5 when not provided."""
        with app.app.test_client() as client:
            with patch("app.GitHubUtils") as mock_github_utils:
                with patch("app.load_config") as mock_load_config:
                    mock_load_config.return_value = {
                        "github": {"token": "test_token"}
                    }

                    # Test without max_issues in form data
                    response = client.post(
                        "/generate",
>                       data={"github_repo": self.test_repo},
                                             ^^^^^^^^^^^^^^
                        follow_redirects=True,
                    )
E                   AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:413: AttributeError
_______________________________________________________________________________ TestGenerateIssuesRoute.test_generate_issues_invalid_max_issues ________________________________________________________________________________

self = <tests.test_app.TestGenerateIssuesRoute object at 0x10ce58800>

    def test_generate_issues_invalid_max_issues(self):
        """Test that invalid max_issues defaults to 5."""
        with app.app.test_client() as client:
            with patch("app.GitHubUtils") as mock_github_utils:
                with patch("app.load_config") as mock_load_config:
                    mock_load_config.return_value = {
                        "github": {"token": "test_token"}
                    }

                    # Test with invalid max_issues
                    response = client.post(
                        "/generate",
                        data={
>                           "github_repo": self.test_repo,
                                           ^^^^^^^^^^^^^^
                            "max_issues": "invalid",
                        },
                        follow_redirects=True,
                    )
E                   AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'

tests/test_app.py:432: AttributeError
______________________________________________________________________________________ TestSupportsColor.test_supports_color_no_color_env ______________________________________________________________________________________

self = <tests.test_colors.TestSupportsColor object at 0x10ce6d790>, mock_stdout = <MagicMock name='stdout' id='4513786064'>

    @patch("sys.stdout")
    @patch.dict(os.environ, {"NO_COLOR": "1", "TERM": "xterm-256color"})
    def test_supports_color_no_color_env(self, mock_stdout):
        """Test that NO_COLOR environment variable disables colors."""
        mock_stdout.isatty.return_value = True
>       assert supports_color() is False
E       assert True is False
E        +  where True = supports_color()

tests/test_colors.py:141: AssertionError
____________________________________________________________________________________ TestSupportsColor.test_supports_color_force_color_env _____________________________________________________________________________________

self = <tests.test_colors.TestSupportsColor object at 0x10ce6d820>, mock_stdout = <MagicMock name='stdout' id='4513784864'>

    @patch("sys.stdout")
    @patch.dict(os.environ, {"FORCE_COLOR": "1", "TERM": "dumb"})
    def test_supports_color_force_color_env(self, mock_stdout):
        """Test that FORCE_COLOR environment variable enables colors."""
        mock_stdout.isatty.return_value = True
>       assert supports_color() is True
E       assert False is True
E        +  where False = supports_color()

tests/test_colors.py:148: AssertionError
__________________________________________________________________________________________ TestEdgeCases.test_progress_bar_edge_cases __________________________________________________________________________________________

self = <tests.test_colors.TestEdgeCases object at 0x10ceb7140>

    def test_progress_bar_edge_cases(self):
        """Test progress bar with edge cases."""
        enable_colors(True)

        # Test with completed > total
        result = progress_bar(15, 10, width=10)
        expected = f"[{Colors.GREEN}██████████{Colors.RESET}] 150.0%"
>       assert result == expected
E       AssertionError: assert '[\x1b[92m███...1b[0m] 150.0%' == '[\x1b[92m███...1b[0m] 150.0%'
E
E         - [██████████] 150.0%
E         + [███████████████] 150.0%
E         ?                 +++++

tests/test_colors.py:464: AssertionError
_________________________________________________________________________________________ TestDataScraper.test_scrape_content_analysis _________________________________________________________________________________________

self = <tests.test_data_scraper.TestDataScraper testMethod=test_scrape_content_analysis>

    def test_scrape_content_analysis(self):
        """Test content analysis."""
        analysis = self.scraper.scrape_content_analysis()

        self.assertIn("programming_languages", analysis)
        self.assertIn("configuration_files", analysis)

        # Should detect Python files
>       self.assertIn("Python", analysis["programming_languages"])
E       AssertionError: 'Python' not found in {}

tests/test_data_scraper.py:62: AssertionError
__________________________________________________________________________________________ TestDataScraper.test_scrape_file_structure __________________________________________________________________________________________

self = <tests.test_data_scraper.TestDataScraper testMethod=test_scrape_file_structure>

    def test_scrape_file_structure(self):
        """Test file structure analysis."""
        structure = self.scraper.scrape_file_structure()

        self.assertIn("total_files", structure)
        self.assertIn("file_types", structure)
        self.assertIn("directories", structure)
>       self.assertGreater(structure["total_files"], 0)
E       AssertionError: 0 not greater than 0

tests/test_data_scraper.py:52: AssertionError
_____________________________________________________________________________________ TestGitHubUtils.test_clone_repository_public_success _____________________________________________________________________________________

self = <tests.test_github_utils.TestGitHubUtils object at 0x10cffe270>, mock_get_info = <MagicMock name='get_repository_info' id='5056260736'>, mock_clone = <MagicMock name='clone_from' id='5056252624'>

    @patch("github_utils.Repo.clone_from")
    @patch("github_utils.GitHubUtils.get_repository_info")
    def test_clone_repository_public_success(self, mock_get_info, mock_clone):
        """Test successful cloning of public repository."""
        # Mock repository info
        mock_get_info.return_value = {
            "private": False,
            "clone_url": "https://github.com/owner/repo.git",
        }

        # Mock successful clone
        mock_repo = Mock()
        mock_clone.return_value = mock_repo

        result = self.github_utils.clone_repository("owner/repo")

        assert result is not None
>       assert result.startswith("/tmp/ticket-master-owner-repo-")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x12d5e76b0>('/tmp/ticket-master-owner-repo-')
E        +    where <built-in method startswith of str object at 0x12d5e76b0> = '/var/folders/zd/qd5flt2j43722srmc5kg9f6h0000gn/T/ticket-master-owner-repo-t5o2der8'.startswith

tests/test_github_utils.py:188: AssertionError
_____________________________________________________________________________________ TestGitHubUtils.test_clone_repository_to_local_path ______________________________________________________________________________________

self = <tests.test_github_utils.TestGitHubUtils object at 0x10cffe780>, mock_get_info = <MagicMock name='get_repository_info' id='5056146336'>, mock_clone = <MagicMock name='clone_from' id='5056150848'>

    @patch("github_utils.Repo.clone_from")
    @patch("github_utils.GitHubUtils.get_repository_info")
    def test_clone_repository_to_local_path(self, mock_get_info, mock_clone):
        """Test cloning repository to specified local path."""
        # Mock repository info
        mock_get_info.return_value = {
            "private": False,
            "clone_url": "https://github.com/owner/repo.git",
        }

        # Mock successful clone
        mock_repo = Mock()
        mock_clone.return_value = mock_repo

        with tempfile.TemporaryDirectory() as temp_dir:
            local_path = os.path.join(temp_dir, "test-repo")

            result = self.github_utils.clone_repository(
                "owner/repo", local_path=local_path
            )

>           assert result == os.path.abspath(local_path)
E           AssertionError: assert '/private/var...pnj/test-repo' == '/var/folders...pnj/test-repo'
E
E             - /var/folders/zd/qd5flt2j43722srmc5kg9f6h0000gn/T/tmpfui_vpnj/test-repo
E             + /private/var/folders/zd/qd5flt2j43722srmc5kg9f6h0000gn/T/tmpfui_vpnj/test-repo
E             ? ++++++++

tests/test_github_utils.py:249: AssertionError
____________________________________________________________________________________ TestGitHubUtilsAdvanced.test_empty_repository_handling ____________________________________________________________________________________

self = <tests.test_github_utils.TestGitHubUtilsAdvanced object at 0x10cfff4a0>

    def test_empty_repository_handling(self):
        """Test handling of empty repositories."""
        # Create an empty temporary directory to simulate empty repo
        with tempfile.TemporaryDirectory() as temp_dir:
            # Initialize as git repo but keep it empty
            import git

            repo = git.Repo.init(temp_dir)

            # Add a commit to avoid "reference does not exist" error
            # Create an empty commit
>           repo.index.commit("Initial empty commit", allow_empty=True)
E           TypeError: IndexFile.commit() got an unexpected keyword argument 'allow_empty'

tests/test_github_utils.py:503: TypeError
____________________________________________________________________________________ TestEndToEndIntegration.test_dry_run_issue_processing _____________________________________________________________________________________

self = <tests.test_integration.TestEndToEndIntegration testMethod=test_dry_run_issue_processing>

    def test_dry_run_issue_processing(self):
        """Test dry run issue processing workflow."""
>       from ticket_master import Issue
E       ImportError: cannot import name 'Issue' from 'ticket_master' (unknown location)

tests/test_integration.py:219: ImportError
__________________________________________________________________________________ TestEndToEndIntegration.test_llm_issue_generation_pipeline __________________________________________________________________________________

self = <tests.test_integration.TestEndToEndIntegration testMethod=test_llm_issue_generation_pipeline>

    def test_llm_issue_generation_pipeline(self):
        """Test complete pipeline using LLM issue generation."""
        # Create minimal analysis data
        analysis = {
            "repository_info": {"name": "test-repo", "active_branch": "main"},
            "commits": [
                {
                    "hash": "abc123",
                    "short_hash": "abc123",
                    "summary": "Add new feature",
                    "author": {
                        "name": "Test User",
                        "email": "test@example.com",
                    },
                    "committer": {
                        "name": "Test User",
                        "email": "test@example.com",
                    },
                    "message": "Add new feature implementation",
                    "date": "2023-01-01T00:00:00",
                    "files_changed": 3,
                    "insertions": 50,
                    "deletions": 10,
                }
            ],
            "file_changes": {
                "modified_files": {
                    "src/main.py": {
                        "changes": 2,
                        "insertions": 30,
                        "deletions": 5,
                        "commits": ["abc123"],
                    }
                },
                "new_files": ["src/feature.py"],
                "deleted_files": [],
                "renamed_files": [],
                "summary": {
                    "total_files": 2,
                    "total_insertions": 50,
                    "total_deletions": 10,
                },
            },
            "analysis_summary": {
                "commit_count": 1,
                "files_modified": 1,
                "files_added": 1,
                "total_insertions": 50,
                "total_deletions": 10,
            },
        }

        # Test LLM issue generation
        issues = generate_issues_with_llm(analysis, self.test_config)

        # Verify results
        self.assertIsInstance(issues, list)
        self.assertGreater(len(issues), 0)
        self.assertLessEqual(
            len(issues), self.test_config["issue_generation"]["max_issues"]
        )

        # Check issue structure
        for issue in issues:
            self.assertIsNotNone(issue.title)
            self.assertIsNotNone(issue.description)
>           self.assertTrue(
                len(issue.description)
                >= self.test_config["issue_generation"][
                    "min_description_length"
                ]
            )
E           AssertionError: False is not true

tests/test_integration.py:169: AssertionError
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
ERROR    main:main.py:548 Unexpected error in LLM issue generation: No module named 'ticket_master.prompt'
________________________________________________________________________________ TestEndToEndIntegration.test_sample_issue_generation_pipeline _________________________________________________________________________________

self = <tests.test_integration.TestEndToEndIntegration testMethod=test_sample_issue_generation_pipeline>

    def test_sample_issue_generation_pipeline(self):
        """Test complete pipeline using sample issue generation."""
        # Create minimal analysis data
        analysis = {
            "repository_info": {"name": "test-repo", "active_branch": "main"},
            "commits": [
                {
                    "hash": "abc123",
                    "short_hash": "abc123",
                    "summary": "Test commit",
                    "author": {
                        "name": "Test User",
                        "email": "test@example.com",
                    },
                    "committer": {
                        "name": "Test User",
                        "email": "test@example.com",
                    },
                    "message": "Test commit message",
                    "date": "2023-01-01T00:00:00",
                    "files_changed": 1,
                    "insertions": 10,
                    "deletions": 5,
                }
            ],
            "file_changes": {
                "modified_files": {},
                "new_files": [],
                "deleted_files": [],
                "renamed_files": [],
                "summary": {
                    "total_files": 1,
                    "total_insertions": 10,
                    "total_deletions": 5,
                },
            },
            "analysis_summary": {
                "commit_count": 1,
                "files_modified": 1,
                "files_added": 0,
                "total_insertions": 10,
                "total_deletions": 5,
            },
        }

        # Test sample issue generation
        issues = generate_sample_issues(analysis, self.test_config)

        # Verify results
        self.assertIsInstance(issues, list)
        self.assertGreater(len(issues), 0)

        # Check first issue
        first_issue = issues[0]
        self.assertIsNotNone(first_issue.title)
        self.assertIsNotNone(first_issue.description)
>       self.assertIsInstance(first_issue.labels, list)
E       AssertionError: <MagicMock name='Issue().labels' id='5056167568'> is not an instance of <class 'list'>

tests/test_integration.py:100: AssertionError
_____________________________________________________________________________ TestIssueGitHubIntegration.test_create_github_client_with_env_token ______________________________________________________________________________

args = (<tests.test_issue.TestIssueGitHubIntegration object at 0x10d005b80>,), kw = {}

    @wraps(f)
    def _inner(*args, **kw):
        self._patch_dict()
        try:
>           return f(*args, **kw)
                   ^^^^^^^^^^^^^^

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1861:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.auth'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________ TestIssueGitHubIntegration.test_create_github_client_with_explicit_token ___________________________________________________________________________

args = (<tests.test_issue.TestIssueGitHubIntegration object at 0x10d0058b0>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.auth'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________ TestIssueGitHubIntegration.test_create_github_client_bad_credentials _____________________________________________________________________________

args = (<tests.test_issue.TestIssueGitHubIntegration object at 0x10d004cb0>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.auth'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________________ TestIssueGitHubIntegration.test_create_on_github_success ___________________________________________________________________________________

args = (<tests.test_issue.TestIssueGitHubIntegration object at 0x10d005130>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.issue.Issue'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.issue.Issue'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_________________________________________________________________________________ TestIssueGitHubIntegration.test_create_on_github_with_labels _________________________________________________________________________________

args = (<tests.test_issue.TestIssueGitHubIntegration object at 0x10d005400>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.issue.Issue'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.issue.Issue'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________________ TestGitHubConnection.test_test_github_connection_success ___________________________________________________________________________________

args = (<tests.test_issue.TestGitHubConnection object at 0x10d0053d0>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.auth.Authentication'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.auth.Authentication'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________________ TestGitHubConnection.test_test_github_connection_failure ___________________________________________________________________________________

args = (<tests.test_issue.TestGitHubConnection object at 0x10d005820>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.auth.Authentication'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.auth.Authentication'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestGenerateSampleIssues.test_generate_sample_issues_basic __________________________________________________________________________________

self = <tests.test_main.TestGenerateSampleIssues testMethod=test_generate_sample_issues_basic>

    def test_generate_sample_issues_basic(self):
        """Test basic issue generation."""
        issues = main.generate_sample_issues(self.analysis, self.config)

        self.assertIsInstance(issues, list)
        self.assertLessEqual(
            len(issues), self.config["issue_generation"]["max_issues"]
        )

        # Check that issues are Issue objects
        for issue in issues:
>           self.assertIsInstance(issue, main.Issue)
E           TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union

tests/test_main.py:128: TypeError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - Generated 4 sample issues
2025-09-29 01:08:28 - main - INFO - Generated 4 sample issues
2025-09-29 01:08:28 - main - INFO - Generated 4 sample issues
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:708 Generated 4 sample issues
________________________________________________________________________ TestValidateConfigCommand.test_validate_config_command_missing_required_fields ________________________________________________________________________

self = <tests.test_main.TestValidateConfigCommand testMethod=test_validate_config_command_missing_required_fields>, mock_print = <MagicMock name='print' id='5056073744'>
mock_load_config = <MagicMock name='load_config' id='5056264576'>

    @patch("main.load_config")
    @patch("builtins.print")
    def test_validate_config_command_missing_required_fields(
        self, mock_print, mock_load_config
    ):
        """Test validate_config_command with missing required fields."""
        # Return config missing some required fields
        mock_load_config.return_value = {"github": {}}  # Missing token

        result = main.validate_config_command()

        # Should still return 0 but print validation messages
>       self.assertEqual(result, 0)
E       AssertionError: 1 != 0

tests/test_main.py:337: AssertionError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:929 Validating configuration...
_____________________________________________________________________________ TestValidateConfigCommand.test_validate_config_command_valid_config ______________________________________________________________________________

self = <tests.test_main.TestValidateConfigCommand testMethod=test_validate_config_command_valid_config>, mock_print = <MagicMock name='print' id='5056030496'>
mock_load_config = <MagicMock name='load_config' id='5056022960'>

    @patch("main.load_config")
    @patch("builtins.print")
    def test_validate_config_command_valid_config(
        self, mock_print, mock_load_config
    ):
        """Test validate_config_command with valid configuration."""
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
        }

        result = main.validate_config_command()

>       self.assertEqual(result, 0)
E       AssertionError: 1 != 0

tests/test_main.py:304: AssertionError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:929 Validating configuration...
_______________________________________________________________________________ TestValidateConfigCommand.test_validate_config_command_with_path _______________________________________________________________________________

self = <tests.test_main.TestValidateConfigCommand testMethod=test_validate_config_command_with_path>, mock_print = <MagicMock name='print' id='5055929648'>, mock_load_config = <MagicMock name='load_config' id='5055932576'>

    @patch("main.load_config")
    @patch("builtins.print")
    def test_validate_config_command_with_path(
        self, mock_print, mock_load_config
    ):
        """Test validate_config_command with specific config path."""
        mock_load_config.return_value = {
            "github": {"token": "test_token"},
            "issue_generation": {"max_issues": 5},
        }

        result = main.validate_config_command("/path/to/config.yaml")

>       self.assertEqual(result, 0)
E       AssertionError: 1 != 0

tests/test_main.py:321: AssertionError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
2025-09-29 01:08:28 - main - INFO - Validating configuration...
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:929 Validating configuration...
____________________________________________________________________________________ TestAnalyzeRepository.test_analyze_repository_success _____________________________________________________________________________________

repo_path = '/path/to/repo', config = {'repository': {'max_commits': 100}}

    def analyze_repository(
        repo_path: str, config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Analyze repository and prepare data for issue generation.

        Args:
            repo_path: Path to Git repository
            config: Configuration dictionary

        Returns:
            Dictionary containing repository analysis results

        Raises:
            RepositoryError: If repository analysis fails
        """
        logger = logging.getLogger(__name__)

        try:
            # Initialize repository
            repo = Repository(repo_path)
            logger.info(f"Analyzing repository: {repo.path}")

            # Get repository information
            repo_info = repo.get_repository_info()
            logger.info(
>               f"Repository: {repo_info['name']} ({repo_info['active_branch']})"
                               ^^^^^^^^^^^^^^^^^
            )
E           TypeError: 'Mock' object is not subscriptable

main.py:219: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_main.TestAnalyzeRepository testMethod=test_analyze_repository_success>, mock_repository = <MagicMock name='Repository' id='5055872032'>

    @patch("main.Repository")
    def test_analyze_repository_success(self, mock_repository):
        """Test successful repository analysis."""
        mock_repo_instance = Mock()
        mock_repo_instance.analyze.return_value = {
            "commits": [],
            "file_changes": {"new_files": [], "modified_files": {}},
            "summary": {"commit_count": 0},
        }
        mock_repository.return_value = mock_repo_instance

        config = {"repository": {"max_commits": 100}}
>       result = main.analyze_repository("/path/to/repo", config)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main.py:357:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

repo_path = '/path/to/repo', config = {'repository': {'max_commits': 100}}

    def analyze_repository(
        repo_path: str, config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Analyze repository and prepare data for issue generation.

        Args:
            repo_path: Path to Git repository
            config: Configuration dictionary

        Returns:
            Dictionary containing repository analysis results

        Raises:
            RepositoryError: If repository analysis fails
        """
        logger = logging.getLogger(__name__)

        try:
            # Initialize repository
            repo = Repository(repo_path)
            logger.info(f"Analyzing repository: {repo.path}")

            # Get repository information
            repo_info = repo.get_repository_info()
            logger.info(
                f"Repository: {repo_info['name']} ({repo_info['active_branch']})"
            )

            # Try to get commit history, but fall back to minimal analysis if it fails
            max_commits = config["repository"]["max_commits"]
            try:
                commits = repo.get_commit_history(max_count=max_commits)
                logger.info(f"Retrieved {len(commits)} commits")
            except Exception as commit_error:
                logger.warning(
                    f"Could not get detailed commit history: {commit_error}"
                )
                logger.info("Using minimal commit analysis")
                commits = [
                    {
                        "hash": "unknown",
                        "short_hash": "unknown",
                        "author": {"name": "unknown", "email": "unknown"},
                        "committer": {"name": "unknown", "email": "unknown"},
                        "message": "Repository analysis limited due to git issues",
                        "summary": "Limited analysis mode",
                        "date": datetime.now(),
                        "files_changed": 0,
                        "insertions": 0,
                        "deletions": 0,
                    }
                ]

            # Try to get file changes, but fall back to minimal analysis if it fails
            try:
                file_changes = repo.get_file_changes(max_commits=max_commits)
                logger.info(
                    f"Analyzed changes across "
                    f"{file_changes['summary']['total_files']} files"
                )
            except Exception as file_error:
                logger.warning(
                    f"Could not get detailed file changes: {file_error}"
                )
                logger.info("Using minimal file change analysis")
                file_changes = {
                    "modified_files": {},
                    "new_files": [],
                    "deleted_files": [],
                    "renamed_files": [],
                    "summary": {
                        "total_files": 1,
                        "total_insertions": 0,
                        "total_deletions": 0,
                    },
                }

            return {
                "repository_info": repo_info,
                "commits": commits,
                "file_changes": file_changes,
                "analysis_summary": {
                    "commit_count": len(commits),
                    "files_modified": len(file_changes["modified_files"]),
                    "files_added": len(file_changes["new_files"]),
                    "files_deleted": len(file_changes["deleted_files"]),
                    "total_insertions": file_changes["summary"][
                        "total_insertions"
                    ],
                    "total_deletions": file_changes["summary"]["total_deletions"],
                },
            }

        except Exception as e:
>           raise RepositoryError(f"Repository analysis failed: {e}")
E           repository.RepositoryError: Repository analysis failed: 'Mock' object is not subscriptable

main.py:288: RepositoryError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - Analyzing repository: <Mock name='Repository().path' id='5055868624'>
2025-09-29 01:08:28 - main - INFO - Analyzing repository: <Mock name='Repository().path' id='5055868624'>
2025-09-29 01:08:28 - main - INFO - Analyzing repository: <Mock name='Repository().path' id='5055868624'>
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:214 Analyzing repository: <Mock name='Repository().path' id='5055868624'>
_______________________________________________________________________________ TestGenerateIssuesWithLLM.test_generate_issues_with_llm_fallback _______________________________________________________________________________

self = <tests.test_main.TestGenerateIssuesWithLLM testMethod=test_generate_issues_with_llm_fallback>, mock_generate_standard = <MagicMock name='generate_issues_with_standard_llm' id='5055868096'>
mock_generate_sample = <MagicMock name='generate_sample_issues' id='5055893376'>

    @patch("main.generate_sample_issues")
    @patch("main.generate_issues_with_standard_llm")
    def test_generate_issues_with_llm_fallback(
        self, mock_generate_standard, mock_generate_sample
    ):
        """Test LLM issue generation fallback to samples."""
        config = {"llm": {"provider": "ollama"}}
        mock_generate_standard.side_effect = Exception("LLM error")

        mock_issue = Mock()
        mock_issue.title = "Sample Issue"
        mock_generate_sample.return_value = [mock_issue]

        result = main.generate_issues_with_llm(self.analysis, config)

        self.assertEqual(len(result), 1)
>       mock_generate_standard.assert_called_once()

tests/test_main.py:414:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='generate_issues_with_standard_llm' id='5055868096'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'generate_issues_with_standard_llm' to have been called once. Called 0 times.

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:928: AssertionError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
ERROR    main:main.py:381 Unexpected error in LLM issue generation: 'issue_generation'
INFO     main:main.py:382 Falling back to sample issue generation
_______________________________________________________________________________ TestGenerateIssuesWithLLM.test_generate_issues_with_llm_success ________________________________________________________________________________

analysis = {'commits': [], 'file_changes': {'modified_files': {}, 'new_files': []}, 'summary': {'commit_count': 0}}, config = {'llm': {'provider': 'ollama'}}

    def generate_issues_with_llm(
        analysis: Dict[str, Any], config: Dict[str, Any]
    ) -> List[Issue]:
        """Generate issues using LLM based on repository analysis.

        Args:
            analysis: Repository analysis results
            config: Configuration dictionary

        Returns:
            List of generated Issue objects
        """
        logger = logging.getLogger(__name__)
        issues = []

        try:
            # Get max issues from config
>           max_issues = config["issue_generation"]["max_issues"]
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'issue_generation'

main.py:308: KeyError

During handling of the above exception, another exception occurred:

self = <tests.test_main.TestGenerateIssuesWithLLM testMethod=test_generate_issues_with_llm_success>, mock_generate_standard = <MagicMock name='generate_issues_with_standard_llm' id='5055858352'>

    @patch("main.generate_issues_with_standard_llm")
    def test_generate_issues_with_llm_success(self, mock_generate_standard):
        """Test successful LLM issue generation."""
        config = {"llm": {"provider": "ollama"}}
        mock_issue = Mock()
        mock_issue.title = "Test Issue"
        mock_generate_standard.return_value = [mock_issue]

>       result = main.generate_issues_with_llm(self.analysis, config)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_main.py:393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
main.py:383: in generate_issues_with_llm
    return generate_sample_issues(analysis, config)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

analysis = {'commits': [], 'file_changes': {'modified_files': {}, 'new_files': []}, 'summary': {'commit_count': 0}}, config = {'llm': {'provider': 'ollama'}}

    def generate_sample_issues(
        analysis: Dict[str, Any], config: Dict[str, Any]
    ) -> List[Issue]:
        """Generate sample issues based on repository analysis.

        This is a fallback implementation that generates basic issues based on
        repository patterns when LLM is not available.

        Args:
            analysis: Repository analysis results
            config: Configuration dictionary

        Returns:
            List of generated Issue objects
        """
        logger = logging.getLogger(__name__)
        issues = []

        commits = analysis["commits"]
        file_changes = analysis["file_changes"]
>       summary = analysis["analysis_summary"]
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'analysis_summary'

main.py:573: KeyError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - ERROR - Unexpected error in LLM issue generation: 'issue_generation'
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
2025-09-29 01:08:28 - main - INFO - Falling back to sample issue generation
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
ERROR    main:main.py:381 Unexpected error in LLM issue generation: 'issue_generation'
INFO     main:main.py:382 Falling back to sample issue generation
________________________________________________________________________________ TestCreateIssuesOnGitHub.test_create_issues_on_github_dry_run _________________________________________________________________________________

self = <tests.test_main.TestCreateIssuesOnGitHub testMethod=test_create_issues_on_github_dry_run>, mock_issue_class = <MagicMock name='Issue' id='5055864736'>

    @patch("main.Issue")
    def test_create_issues_on_github_dry_run(self, mock_issue_class):
        """Test creating issues in dry run mode."""
        config = {"github": {"token": "test_token"}}
        issues = [self.mock_issue]

        results = main.create_issues_on_github(
            issues, "test/repo", config, dry_run=True
        )

        self.assertEqual(len(results), 1)
>       self.assertTrue(results[0]["dry_run"])
                        ^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'dry_run'

tests/test_main.py:439: KeyError
----------------------------------------------------------------------------------------------------- Captured stdout call -----------------------------------------------------------------------------------------------------
2025-09-29 01:08:28 - main - INFO - DRY RUN MODE: Issues will be validated but not created
2025-09-29 01:08:28 - main - INFO - DRY RUN MODE: Issues will be validated but not created
2025-09-29 01:08:28 - main - INFO - DRY RUN MODE: Issues will be validated but not created
2025-09-29 01:08:28 - main - INFO - Skipping GitHub connection test in dry-run mode
2025-09-29 01:08:28 - main - INFO - Skipping GitHub connection test in dry-run mode
2025-09-29 01:08:28 - main - INFO - Skipping GitHub connection test in dry-run mode
2025-09-29 01:08:28 - main - ERROR - Failed to create issue 1: can only join an iterable
2025-09-29 01:08:28 - main - ERROR - Failed to create issue 1: can only join an iterable
2025-09-29 01:08:28 - main - ERROR - Failed to create issue 1: can only join an iterable
------------------------------------------------------------------------------------------------------ Captured log call -------------------------------------------------------------------------------------------------------
INFO     main:main.py:737 DRY RUN MODE: Issues will be validated but not created
INFO     main:main.py:763 Skipping GitHub connection test in dry-run mode
ERROR    main:main.py:814 Failed to create issue 1: can only join an iterable
________________________________________________________________________________ TestCreateIssuesOnGitHub.test_create_issues_on_github_failure _________________________________________________________________________________

issues = [<Mock id='5055857584'>], repo_name = 'test/repo', config = {'github': {'token': 'test_token'}}, dry_run = False

    def create_issues_on_github(
        issues: List[Issue],
        repo_name: str,
        config: Dict[str, Any],
        dry_run: bool = True,
    ) -> List[Dict[str, Any]]:
        """Create issues on GitHub.

        Args:
            issues: List of Issue objects to create
            repo_name: GitHub repository name (owner/repo)
            config: Configuration dictionary
            dry_run: If True, validate but don't actually create issues

        Returns:
            List of dictionaries containing creation results

        Raises:
            GitHubAuthError: If GitHub authentication fails
            IssueError: If issue creation fails
        """
        logger = logging.getLogger(__name__)
        results = []

        if dry_run:
            logger.info("DRY RUN MODE: Issues will be validated but not created")

        # Test GitHub connection first (skip if using dummy token or dry run)
        github_token = config["github"]["token"]
        if not dry_run and github_token and github_token != "dummy_token":
            try:
>               from ticket_master.issue import test_github_connection
E               ModuleNotFoundError: No module named 'ticket_master.issue'

main.py:743: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_main.TestCreateIssuesOnGitHub testMethod=test_create_issues_on_github_failure>, mock_issue_class = <MagicMock name='Issue' id='5055857632'>

    @patch("main.Issue")
    def test_create_issues_on_github_failure(self, mock_issue_class):
        """Test issue creation failure."""
        config = {"github": {"token": "test_token"}}
        issues = [self.mock_issue]

        mock_github_issue = Mock()
        mock_github_issue.create_issue.side_effect = Exception(
            "Creation failed"
        )
        mock_issue_class.return_value = mock_github_issue

>       results = main.create_issues_on_github(
            issues, "test/repo", config, dry_run=False
        )

tests/test_main.py:478:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

issues = [<Mock id='5055857584'>], repo_name = 'test/repo', config = {'github': {'token': 'test_token'}}, dry_run = False

    def create_issues_on_github(
        issues: List[Issue],
        repo_name: str,
        config: Dict[str, Any],
        dry_run: bool = True,
    ) -> List[Dict[str, Any]]:
        """Create issues on GitHub.

        Args:
            issues: List of Issue objects to create
            repo_name: GitHub repository name (owner/repo)
            config: Configuration dictionary
            dry_run: If True, validate but don't actually create issues

        Returns:
            List of dictionaries containing creation results

        Raises:
            GitHubAuthError: If GitHub authentication fails
            IssueError: If issue creation fails
        """
        logger = logging.getLogger(__name__)
        results = []

        if dry_run:
            logger.info("DRY RUN MODE: Issues will be validated but not created")

        # Test GitHub connection first (skip if using dummy token or dry run)
        github_token = config["github"]["token"]
        if not dry_run and github_token and github_token != "dummy_token":
            try:
                from ticket_master.issue import test_github_connection

                connection_test = test_github_connection(github_token)

                if not connection_test["authenticated"]:
                    raise GitHubAuthError(
                        f"GitHub authentication failed: {connection_test['error']}"
                    )

                logger.info(
                    f"Connected to GitHub as: {connection_test['user']['login']}"
                )
                logger.info(
                    f"Rate limit remaining: {connection_test['rate_limit']['core']['remaining']}"
                )

            except Exception as e:
>               raise GitHubAuthError(f"Failed to connect to GitHub: {e}")
E               issue.GitHubAuthError: Failed to connect to GitHub: No module named 'ticket_master.issue'

main.py:760: GitHubAuthError
________________________________________________________________________________ TestCreateIssuesOnGitHub.test_create_issues_on_github_success _________________________________________________________________________________

issues = [<Mock id='5055930608'>], repo_name = 'test/repo', config = {'github': {'token': 'test_token'}}, dry_run = False

    def create_issues_on_github(
        issues: List[Issue],
        repo_name: str,
        config: Dict[str, Any],
        dry_run: bool = True,
    ) -> List[Dict[str, Any]]:
        """Create issues on GitHub.

        Args:
            issues: List of Issue objects to create
            repo_name: GitHub repository name (owner/repo)
            config: Configuration dictionary
            dry_run: If True, validate but don't actually create issues

        Returns:
            List of dictionaries containing creation results

        Raises:
            GitHubAuthError: If GitHub authentication fails
            IssueError: If issue creation fails
        """
        logger = logging.getLogger(__name__)
        results = []

        if dry_run:
            logger.info("DRY RUN MODE: Issues will be validated but not created")

        # Test GitHub connection first (skip if using dummy token or dry run)
        github_token = config["github"]["token"]
        if not dry_run and github_token and github_token != "dummy_token":
            try:
>               from ticket_master.issue import test_github_connection
E               ModuleNotFoundError: No module named 'ticket_master.issue'

main.py:743: ModuleNotFoundError

During handling of the above exception, another exception occurred:

self = <tests.test_main.TestCreateIssuesOnGitHub testMethod=test_create_issues_on_github_success>, mock_issue_class = <MagicMock name='Issue' id='5055936752'>

    @patch("main.Issue")
    def test_create_issues_on_github_success(self, mock_issue_class):
        """Test successful issue creation."""
        config = {"github": {"token": "test_token"}}
        issues = [self.mock_issue]

        mock_github_issue = Mock()
        mock_github_issue.create_issue.return_value = {
            "number": 123,
            "html_url": "https://github.com/test/repo/issues/123",
        }
        mock_issue_class.return_value = mock_github_issue

>       results = main.create_issues_on_github(
            issues, "test/repo", config, dry_run=False
        )

tests/test_main.py:457:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

issues = [<Mock id='5055930608'>], repo_name = 'test/repo', config = {'github': {'token': 'test_token'}}, dry_run = False

    def create_issues_on_github(
        issues: List[Issue],
        repo_name: str,
        config: Dict[str, Any],
        dry_run: bool = True,
    ) -> List[Dict[str, Any]]:
        """Create issues on GitHub.

        Args:
            issues: List of Issue objects to create
            repo_name: GitHub repository name (owner/repo)
            config: Configuration dictionary
            dry_run: If True, validate but don't actually create issues

        Returns:
            List of dictionaries containing creation results

        Raises:
            GitHubAuthError: If GitHub authentication fails
            IssueError: If issue creation fails
        """
        logger = logging.getLogger(__name__)
        results = []

        if dry_run:
            logger.info("DRY RUN MODE: Issues will be validated but not created")

        # Test GitHub connection first (skip if using dummy token or dry run)
        github_token = config["github"]["token"]
        if not dry_run and github_token and github_token != "dummy_token":
            try:
                from ticket_master.issue import test_github_connection

                connection_test = test_github_connection(github_token)

                if not connection_test["authenticated"]:
                    raise GitHubAuthError(
                        f"GitHub authentication failed: {connection_test['error']}"
                    )

                logger.info(
                    f"Connected to GitHub as: {connection_test['user']['login']}"
                )
                logger.info(
                    f"Rate limit remaining: {connection_test['rate_limit']['core']['remaining']}"
                )

            except Exception as e:
>               raise GitHubAuthError(f"Failed to connect to GitHub: {e}")
E               issue.GitHubAuthError: Failed to connect to GitHub: No module named 'ticket_master.issue'

main.py:760: GitHubAuthError
_________________________________________________________________________________________ TestDataScraper.test_scrape_content_analysis _________________________________________________________________________________________

self = <tests.test_new_classes.TestDataScraper testMethod=test_scrape_content_analysis>

    def test_scrape_content_analysis(self):
        """Test content analysis."""
        analysis = self.scraper.scrape_content_analysis()

        self.assertIn("programming_languages", analysis)
        self.assertIn("configuration_files", analysis)

        # Should detect Python files
>       self.assertIn("Python", analysis["programming_languages"])
E       AssertionError: 'Python' not found in {}

tests/test_new_classes.py:561: AssertionError
__________________________________________________________________________________________ TestDataScraper.test_scrape_file_structure __________________________________________________________________________________________

self = <tests.test_new_classes.TestDataScraper testMethod=test_scrape_file_structure>

    def test_scrape_file_structure(self):
        """Test file structure analysis."""
        structure = self.scraper.scrape_file_structure()

        self.assertIn("total_files", structure)
        self.assertIn("file_types", structure)
        self.assertIn("directories", structure)
>       self.assertGreater(structure["total_files"], 0)
E       AssertionError: 0 not greater than 0

tests/test_new_classes.py:551: AssertionError
_____________________________________________________________________________________ TestOllamaPromptProcessor.test_batch_process_prompts _____________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_batch_process_prompts>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________________ TestOllamaPromptProcessor.test_check_model_availability ____________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_check_model_availability>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_________________________________________________________________________________ TestOllamaPromptProcessor.test_generate_issues_from_analysis _________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_generate_issues_from_analysis>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
________________________________________________________________________________________ TestOllamaPromptProcessor.test_get_model_info _________________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_get_model_info>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________________________ TestOllamaPromptProcessor.test_init ______________________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_init>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_________________________________________________________________________________________ TestOllamaPromptProcessor.test_install_model _________________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_install_model>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestOllamaPromptProcessor.test_parse_issues_response_json ___________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_parse_issues_response_json>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestOllamaPromptProcessor.test_parse_issues_response_text ___________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_parse_issues_response_text>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________________ TestOllamaPromptProcessor.test_process_prompt_api_error ____________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_process_prompt_api_error>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
____________________________________________________________________________________ TestOllamaPromptProcessor.test_process_prompt_success _____________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_process_prompt_success>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestOllamaPromptProcessor.test_process_prompt_with_options __________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaPromptProcessor testMethod=test_process_prompt_with_options>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:25:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
____________________________________________________________________________________ TestOllamaFactoryFunction.test_create_ollama_processor ____________________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_______________________________________________________________________________ TestOllamaFactoryFunction.test_create_ollama_processor_defaults ________________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
________________________________________________________________________________ TestOllamaAdvancedIntegration.test_concurrent_request_handling ________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_concurrent_request_handling>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestOllamaAdvancedIntegration.test_connection_retry_logic ___________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_connection_retry_logic>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_______________________________________________________________________________ TestOllamaAdvancedIntegration.test_custom_generation_parameters ________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_custom_generation_parameters>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________ TestOllamaAdvancedIntegration.test_memory_optimization_large_prompts _____________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_memory_optimization_large_prompts>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
____________________________________________________________________________________ TestOllamaAdvancedIntegration.test_model_info_detailed ____________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_model_info_detailed>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
___________________________________________________________________________ TestOllamaAdvancedIntegration.test_model_installation_failure_scenarios ____________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_model_installation_failure_scenarios>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________ TestOllamaAdvancedIntegration.test_model_installation_with_progress ______________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_model_installation_with_progress>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
______________________________________________________________________________________ TestOllamaAdvancedIntegration.test_model_switching ______________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_model_switching>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
________________________________________________________________________________ TestOllamaAdvancedIntegration.test_response_streaming_handling ________________________________________________________________________________

self = <tests.test_ollama_tools.TestOllamaAdvancedIntegration testMethod=test_response_streaming_handling>

    def setUp(self):
        """Set up test fixtures."""
>       with patch(".ollama_tools.ollama"):
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_ollama_tools.py:517:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
__________________________________________________________________________________ TestOllamaErrorRecovery.test_insufficient_memory_handling ___________________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________________ TestOllamaErrorRecovery.test_invalid_prompt_handling _____________________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_________________________________________________________________________________ TestOllamaErrorRecovery.test_model_loading_timeout_handling __________________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________ TestOllamaErrorRecovery.test_server_unavailable_graceful_degradation _____________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.ollama_tools'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.ollama_tools'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
_____________________________________________________________________________ TestLargeRepositoryPerformance.test_bulk_data_processing_performance _____________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.ticket_master.data_scraper'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.ticket_master' has no attribute 'data_scraper'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError
_____________________________________________________________________________ TestLargeRepositoryPerformance.test_large_commit_history_performance _____________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.ticket_master.repository.git'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.ticket_master' has no attribute 'repository'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError
_______________________________________________________________________________ TestLargeRepositoryPerformance.test_large_file_count_performance _______________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.ticket_master.repository.git'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.ticket_master' has no attribute 'repository'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError
______________________________________________________________________________ TestBulkOperationsPerformance.test_bulk_issue_creation_performance ______________________________________________________________________________
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393: in patched
    with self.decoration_helper(patched,
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = 'src.ticket_master.issue'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.ticket_master' has no attribute 'issue'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:528: AttributeError
___________________________________________________________________________________ TestRepositoryErrorHandling.test_init_with_git_exception ___________________________________________________________________________________

args = (<tests.test_repository.TestRepositoryErrorHandling object at 0x10d1886e0>,), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.repository'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.repository'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
______________________________________________________________________________ TestRepositoryErrorHandling.test_is_ignored_with_subprocess_error _______________________________________________________________________________

args = (<tests.test_repository.TestRepositoryErrorHandling object at 0x10d189160>,), keywargs = {'temp_git_repo_for_error_tests': '/var/folders/zd/qd5flt2j43722srmc5kg9f6h0000gn/T/tmpeslurf8f/test_repo'}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1393:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1451: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

name = '.repository.subprocess'

    def resolve_name(name):
        """
        Resolve a name to an object.

        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:

        W(.W)*
        W(.W)*:(W(.W)*)?

        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.

        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.

        The function will return an object (which might be a module), or raise one
        of the following exceptions:

        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)

        m = _NAME_PATTERN.match(name)
        if not m:
>           raise ValueError(f'invalid format: {name!r}')
E           ValueError: invalid format: '.repository.subprocess'

/opt/homebrew/Cellar/python@3.12/3.12.11_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:501: ValueError
---------------------------------------------------------------------------------------------------- Captured stdout setup -----------------------------------------------------------------------------------------------------
Initialized empty Git repository in /private/var/folders/zd/qd5flt2j43722srmc5kg9f6h0000gn/T/tmpeslurf8f/test_repo/.git/
[master (root-commit) fd59631] Initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
======================================================================================================== tests coverage ========================================================================================================
______________________________________________________________________________________ coverage: platform darwin, python 3.12.11-final-0 _______________________________________________________________________________________

Name                                                                                                                             Stmts   Miss  Cover
----------------------------------------------------------------------------------------------------------------------------------------------------
/opt/homebrew/Cellar/certifi/2025.8.3/lib/python3.12/site-packages/certifi/__init__.py                                               3      0   100%
/opt/homebrew/Cellar/certifi/2025.8.3/lib/python3.12/site-packages/certifi/core.py                                                  27     13    52%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/__about__.py                                      5      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/__init__.py                                       3      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/exceptions.py                                    24      4    83%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/__init__.py                                2      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/_oid.py                                  160      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/backends/__init__.py                       5      2    60%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/bindings/__init__.py                       0      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/decrepit/__init__.py                       1      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/decrepit/ciphers/__init__.py               1      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/decrepit/ciphers/algorithms.py            70     18    74%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/__init__.py                     0      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/_asymmetric.py                  6      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/_cipheralgorithm.py            23      4    83%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/_serialization.py              79     35    56%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/__init__.py          0      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/dsa.py              60      5    92%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/ec.py              198     22    89%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/ed448.py            50     12    76%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/ed25519.py          48     12    75%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/padding.py          54     23    57%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/rsa.py             111     53    52%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/asymmetric/utils.py            14      5    64%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/ciphers/__init__.py             4      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/ciphers/algorithms.py          68     15    78%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/ciphers/base.py                47     12    74%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/ciphers/modes.py              140     59    58%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/hashes.py                     129     20    84%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/serialization/__init__.py       5      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/serialization/base.py           7      0   100%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/hazmat/primitives/serialization/ssh.py          793    627    21%
/opt/homebrew/Cellar/cryptography/46.0.1/lib/python3.12/site-packages/cryptography/utils.py                                         79     29    63%
/opt/homebrew/Cellar/python-setuptools/80.9.0/lib/python3.12/site-packages/_distutils_hack/__init__.py                             101     96     5%
app.py                                                                                                                             146     70    52%
main.py                                                                                                                            494    250    49%
src/__init__.py                                                                                                                     82     40    51%
src/auth.py                                                                                                                         62      6    90%
src/branch.py                                                                                                                       92     40    57%
src/colors.py                                                                                                                       94      2    98%
src/commit.py                                                                                                                       74     33    55%
src/data_scraper.py                                                                                                                359    254    29%
src/database.py                                                                                                                    145     44    70%
src/github_utils.py                                                                                                                119     29    76%
src/issue.py                                                                                                                       202    154    24%
src/llm.py                                                                                                                         421    151    64%
src/ollama_tools.py                                                                                                                205    145    29%
src/pipe.py                                                                                                                        197    102    48%
src/prompt.py                                                                                                                      178     74    58%
src/pull_request.py                                                                                                                105     56    47%
src/repository.py                                                                                                                  172     55    68%
tests/__init__.py                                                                                                                    0      0   100%
tests/test_app.py                                                                                                                  255     62    76%
tests/test_auth.py                                                                                                                 190      5    97%
tests/test_branch.py                                                                                                                62      1    98%
tests/test_colors.py                                                                                                               310      5    98%
tests/test_commit.py                                                                                                                96      1    99%
tests/test_data_scraper.py                                                                                                          33      1    97%
tests/test_database.py                                                                                                              52      2    96%
tests/test_edge_cases.py                                                                                                           156      5    97%
tests/test_examples.py                                                                                                             191     27    86%
tests/test_git_objects.py                                                                                                          377      1    99%
tests/test_github_utils.py                                                                                                         285      7    98%
tests/test_integration.py                                                                                                           55     12    78%
tests/test_issue.py                                                                                                                357    249    30%
tests/test_llm.py                                                                                                                  361      8    98%
tests/test_main.py                                                                                                                 211     24    89%
tests/test_new_classes.py                                                                                                          280      9    97%
tests/test_ollama_tools.py                                                                                                         373    248    34%
tests/test_performance.py                                                                                                          225     70    69%
tests/test_pipe.py                                                                                                                  51      1    98%
tests/test_prompt.py                                                                                                                74      1    99%
tests/test_pull_request.py                                                                                                         109      1    99%
tests/test_repository.py                                                                                                           133      9    93%
----------------------------------------------------------------------------------------------------------------------------------------------------
TOTAL                                                                                                                             9700   3320    66%
=================================================================================================== short test summary info ====================================================================================================
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_private_repo_no_token - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_nonexistent_local_path - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_with_local_path - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_clone_failure - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_repository_error - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_success_public_repo - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_dry_run_flag - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'form_data'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_max_issues_default - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_app.py::TestGenerateIssuesRoute::test_generate_issues_invalid_max_issues - AttributeError: 'TestGenerateIssuesRoute' object has no attribute 'test_repo'
FAILED tests/test_colors.py::TestSupportsColor::test_supports_color_no_color_env - assert True is False
FAILED tests/test_colors.py::TestSupportsColor::test_supports_color_force_color_env - assert False is True
FAILED tests/test_colors.py::TestEdgeCases::test_progress_bar_edge_cases - AssertionError: assert '[\x1b[92m███...1b[0m] 150.0%' == '[\x1b[92m███...1b[0m] 150.0%'
FAILED tests/test_data_scraper.py::TestDataScraper::test_scrape_content_analysis - AssertionError: 'Python' not found in {}
FAILED tests/test_data_scraper.py::TestDataScraper::test_scrape_file_structure - AssertionError: 0 not greater than 0
FAILED tests/test_github_utils.py::TestGitHubUtils::test_clone_repository_public_success - AssertionError: assert False
FAILED tests/test_github_utils.py::TestGitHubUtils::test_clone_repository_to_local_path - AssertionError: assert '/private/var...pnj/test-repo' == '/var/folders...pnj/test-repo'
FAILED tests/test_github_utils.py::TestGitHubUtilsAdvanced::test_empty_repository_handling - TypeError: IndexFile.commit() got an unexpected keyword argument 'allow_empty'
FAILED tests/test_integration.py::TestEndToEndIntegration::test_dry_run_issue_processing - ImportError: cannot import name 'Issue' from 'ticket_master' (unknown location)
FAILED tests/test_integration.py::TestEndToEndIntegration::test_llm_issue_generation_pipeline - AssertionError: False is not true
FAILED tests/test_integration.py::TestEndToEndIntegration::test_sample_issue_generation_pipeline - AssertionError: <MagicMock name='Issue().labels' id='5056167568'> is not an instance of <class 'list'>
FAILED tests/test_issue.py::TestIssueGitHubIntegration::test_create_github_client_with_env_token - ValueError: invalid format: '.auth'
FAILED tests/test_issue.py::TestIssueGitHubIntegration::test_create_github_client_with_explicit_token - ValueError: invalid format: '.auth'
FAILED tests/test_issue.py::TestIssueGitHubIntegration::test_create_github_client_bad_credentials - ValueError: invalid format: '.auth'
FAILED tests/test_issue.py::TestIssueGitHubIntegration::test_create_on_github_success - ValueError: invalid format: '.issue.Issue'
FAILED tests/test_issue.py::TestIssueGitHubIntegration::test_create_on_github_with_labels - ValueError: invalid format: '.issue.Issue'
FAILED tests/test_issue.py::TestGitHubConnection::test_test_github_connection_success - ValueError: invalid format: '.auth.Authentication'
FAILED tests/test_issue.py::TestGitHubConnection::test_test_github_connection_failure - ValueError: invalid format: '.auth.Authentication'
FAILED tests/test_main.py::TestGenerateSampleIssues::test_generate_sample_issues_basic - TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union
FAILED tests/test_main.py::TestValidateConfigCommand::test_validate_config_command_missing_required_fields - AssertionError: 1 != 0
FAILED tests/test_main.py::TestValidateConfigCommand::test_validate_config_command_valid_config - AssertionError: 1 != 0
FAILED tests/test_main.py::TestValidateConfigCommand::test_validate_config_command_with_path - AssertionError: 1 != 0
FAILED tests/test_main.py::TestAnalyzeRepository::test_analyze_repository_success - repository.RepositoryError: Repository analysis failed: 'Mock' object is not subscriptable
FAILED tests/test_main.py::TestGenerateIssuesWithLLM::test_generate_issues_with_llm_fallback - AssertionError: Expected 'generate_issues_with_standard_llm' to have been called once. Called 0 times.
FAILED tests/test_main.py::TestGenerateIssuesWithLLM::test_generate_issues_with_llm_success - KeyError: 'analysis_summary'
FAILED tests/test_main.py::TestCreateIssuesOnGitHub::test_create_issues_on_github_dry_run - KeyError: 'dry_run'
FAILED tests/test_main.py::TestCreateIssuesOnGitHub::test_create_issues_on_github_failure - issue.GitHubAuthError: Failed to connect to GitHub: No module named 'ticket_master.issue'
FAILED tests/test_main.py::TestCreateIssuesOnGitHub::test_create_issues_on_github_success - issue.GitHubAuthError: Failed to connect to GitHub: No module named 'ticket_master.issue'
FAILED tests/test_new_classes.py::TestDataScraper::test_scrape_content_analysis - AssertionError: 'Python' not found in {}
FAILED tests/test_new_classes.py::TestDataScraper::test_scrape_file_structure - AssertionError: 0 not greater than 0
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_batch_process_prompts - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_check_model_availability - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_generate_issues_from_analysis - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_get_model_info - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_init - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_install_model - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_parse_issues_response_json - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_parse_issues_response_text - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_process_prompt_api_error - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_process_prompt_success - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaPromptProcessor::test_process_prompt_with_options - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaFactoryFunction::test_create_ollama_processor - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaFactoryFunction::test_create_ollama_processor_defaults - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_concurrent_request_handling - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_connection_retry_logic - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_custom_generation_parameters - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_memory_optimization_large_prompts - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_model_info_detailed - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_model_installation_failure_scenarios - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_model_installation_with_progress - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_model_switching - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaAdvancedIntegration::test_response_streaming_handling - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaErrorRecovery::test_insufficient_memory_handling - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaErrorRecovery::test_invalid_prompt_handling - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaErrorRecovery::test_model_loading_timeout_handling - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_ollama_tools.py::TestOllamaErrorRecovery::test_server_unavailable_graceful_degradation - ValueError: invalid format: '.ollama_tools'
FAILED tests/test_performance.py::TestLargeRepositoryPerformance::test_bulk_data_processing_performance - AttributeError: module 'src.ticket_master' has no attribute 'data_scraper'
FAILED tests/test_performance.py::TestLargeRepositoryPerformance::test_large_commit_history_performance - AttributeError: module 'src.ticket_master' has no attribute 'repository'
FAILED tests/test_performance.py::TestLargeRepositoryPerformance::test_large_file_count_performance - AttributeError: module 'src.ticket_master' has no attribute 'repository'
FAILED tests/test_performance.py::TestBulkOperationsPerformance::test_bulk_issue_creation_performance - AttributeError: module 'src.ticket_master' has no attribute 'issue'
FAILED tests/test_repository.py::TestRepositoryErrorHandling::test_init_with_git_exception - ValueError: invalid format: '.repository'
FAILED tests/test_repository.py::TestRepositoryErrorHandling::test_is_ignored_with_subprocess_error - ValueError: invalid format: '.repository.subprocess'
=============================================================================================== 71 failed, 365 passed in 41.62s ================================================================================================